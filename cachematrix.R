## *****************************************************************************************
## ***********                 FUNCTION makeCacheMatrix                       **************
## *****************************************************************************************
## makeCacheMatrix takes as input a matrix x, computes a global variable m (the inverse matrix of x)
## and returns an object, which is a list with elements four functions: set, get, setInv, getInv
## We construct all four for the sake of symmetry of our function and for the sake of good programming, 
## but for this project set does not actually need to be used.

##  ***********    List Function set   ***************
## For object ob1, set assigns a matrix y to it as follows: ob1$set(y). 
## set "resets" or "initializes" object ob1 in the sense that it gives value y global scope
## by means of the operator <<- and also sets variable m which holds the inverse to NULL, 
## meaning that the inverse of the given matrix is not yet stored in cache and must be computed.
## Hence, set initializes object ob1 

##  ************   List Function get   *****************
## For object ob1, get displays/outputs the matrix provided as input either in makeCacheMatrix 
## or through the set function as discussed above: ob1$get(). 

##  ************   List Function setInv   *************
## For object ob1, setInv holds the value m of the inverse of x, via the "assign <<-" operator, as 
## computed in function cacheSolve. cacheSolve uses the built-in function solve to invert a matrix. 
## So, value m is hard-wired via "<<-" into ob1 and has global scope. It is set as: ob1@setInv(m)

##  ************   List Function getInv    ***************
## For object ob1, getInv displays/outputs the inverse matrix m rovided as input to setInv. We get 
## m by typing: ob1$getInv().

## ********                         LIST keep (Optional)                        ************
## List keep stores objects that correspond to a different matrix. So, if 2 or more different
## objects (with different environment number) which correspond however to the same matrix x
## are generated, only the first one will be stored in list keep. This step is optional, not
## explicitely required by the project, however, it implements the caching of the actual matrix
## and not the caching of the object. This is the desired purpose of caching an inverse matrix.

## *****************************************************************************************
## ***                            FUNCTION cacheSolve                                    ***
## *****************************************************************************************
## Function cacheSolve takes as input an object ob1 generated by makeCacheMatrix.
## Before it computes the inverse m of the matrix stored in ob1, we want to check if it's 
## already cached not only in object ob1 but in other objects that potentially store the
## same matrix x. So, we take the following steps: 
## 1) Obtain the inverse matrix m by ob$getInv(). If m is not NULL it's been cached already
## and now returned. If however m is NULL then it's not cached and there're two options:
## 2) OPTIONAL: ONLY USE IF implementing caching matrices by value and not by object. Use with 
## list keep. Before we compute the inverse and cache it, we search list keep to identify if any
## other object has cached the same inverse m of original matrix x. We go through the objects of 
## list keep to check via function get()if any stored object has also stored x and hence cached m.
## This is done by increasing counter j and checking statement: identical(keep[[j]]$get(), x$get()). 
## If TRUE then ob1 is substituted by object keep[[j]] which has cached m before, and m is returned.
## 3) If none of 1), 2) holds then we have to compute via function solve() the inverse m of matrix x
## and cache it for the first time, and insert the cached object in the growing list keep.
## Indeed, ob1 becomes the "ith" element of the list, indexed by a global counter i, which is increased
## right after to point to the next empty space of the list. Again operator "<<-" is used to provide i
## global scope. Then we obtain the value of the original matrix x by calling: data <- ob1$get(), compute
## the inverse by calling: m <- solve(data, ...), and store m back in ob1 by calling: ob1$setInv(m). This is
## when we get our non-cached data, which will be cached next time we use the same matrix (x) (my option) or
## the same object ob1.

## ******************      EXECUTION INSTRUCTIONS for the USER         ************
## 1) If you want to run this program to cache matrices by value and not by object (my option) then:
## use the code exactly as provided, and BEFORE YOU START TESTING do the following initializations:
## > i <- 1
## > keep <- NULL
## 2) If you want to run this program to cache matrices only by object (the simplest but not effective
## version described in the project) then do the following:
## PUT COMMENTS on the following code lines at the end of the code in function cacheSolve:
##               ##      keep[[i]] <<- x 
##               ##      i <<- i+1
## Do the following initializations:
## > i <- 0
## > keep <- NULL



##          *****************     REVERSING CACHED MATRIX CODE    ********************

keep <- list(makeCacheMatrix)

makeCacheMatrix <- function(x = matrix()) {
         m <- NULL      
         set <- function(y)  {
                x <<- y
                m <<- NULL              
         }       
         get <- function() x
         setInv <- function(solve) m <<- solve
         getInv <- function() m
         list (set = set, get = get, setInv = setInv, getInv = getInv)
}

cacheSolve <- function(x, ...) {
         ## Return a matrix that is the inverse of 'x'

          m <- x$getInv()
          if (!is.null(m)) {
                  message("getting cached data")
                  return(m)
          }

          if (i>1) {
                    stmt <- "FALSE"
                    for (j in 1:(i-1)) {
                             stmt <- identical(keep[[j]]$get(),x$get())
                             if (stmt) {
                                    x <- keep[[j]]
                                    m <- x$getInv()
                                    message("getting cached data")
                                    return(m)
                             }
                    }
        }
               
        keep[[i]] <<- x 
        i <<- i+1
        data <- x$get()
        m <- solve(data, ...)
        x$setInv(m)
        message("getting non-cached data")
        m
}
