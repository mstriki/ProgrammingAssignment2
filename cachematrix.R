## *********************************************************************************************
## ********                     EXECUTION INSTRUCTIONS for USER/TESTER                  ********
## *********************************************************************************************
## 1) To run this program "caching" matrices by "matrix value" and not by "object value" (my option) then:
## Use the code exactly as provided. Before testing do the following initializations:
## > i <- 1
## > keep <- NULL
## 2) To run this program "caching" matrices only by "object value" (the simplest but not the most effective
## method - project suggestion) do the following:
## PUT COMMENTS in the following code lines at the end of function cacheSolve:
##               ##      keep[[i]] <<- x 
##               ##      i <<- i+1
## Do the following initializations:
## > i <- 0
## > keep <- NULL

## EXECUTION EXAMPLE
## i <- 1
## keep <- NULL
## x <- matrix (c(2,4,8,10),2,2)
## a1 <- makeCacheMatrix(x)
## cacheSolve(a1)

## ************************************************************************************************
## *******                             LIST keep (Optional)                                  ******
## ************************************************************************************************
## List "keep" stores objects corresponding to unique matrices. If > 2 objects are generated from a
## matrix of the same value, only the first is stored in keep. This step is optional but implements
## caching of the actual matrix and not of the object (the desired functionality).

keep <- list(makeCacheMatrix)


## ************************************************************************************************
## ****                                FUNCTION makeCacheMatrix                                ****
## ************************************************************************************************
## makeCacheMatrix takes as input a matrix x and returns an object, which is a list with elements 
## four functions: set, get, setInv, getInv. We construct all for symmetry and for the sake of good 
## programming, but set is not actually used in this project.

##  ***********   Function set  ************
## Resets/initializes object ob1 with matrix x as follows: ob1$set(x). It stores x giving it global
## scope and resets global variable m (inverse of x) to NULL via assign operator "<<-". m <<- NULL 
## means that the inverse of x is not yet computed or stored in cache.

##  ************  Function get  ************
## Outputs the matrix provided as input either via makeCacheMatrix or set function: ob1$get(). 

##  ************  Function setInv  **********
## Stores global value m (inverse of x), as computed in cacheSolve. The assign "<<-" operator makes
## m global. For object ob1 and value m we call setInv as follows: ob1@setInv(m)

##  ************  List Function getInv *******
## Outputs the inverse matrix m provided as input to setInv for object ob1 as follows: ob1$getInv().

makeCacheMatrix <- function(x = matrix()) {

         m <- NULL      
         set <- function(y)  {
                x <<- y
                m <<- NULL              
         }       
         get <- function() x
         setInv <- function(solve) m <<- solve
         getInv <- function() m
         list (set = set, get = get, setInv = setInv, getInv = getInv)
}


## *************************************************************************************************
## ****                                 FUNCTION cacheSolve                                     ****
## *************************************************************************************************
## cacheSolve takes as input object ob1 (holding matrix x) generated by makeCacheMatrix. Before
## computing the inverse m of x, we check whether it's already cached, not only in ob1, but in other
## objects that potentially store a matrix of the same value as x. We do as follows: 

## 1) m <- ob1$getInv(). If (!is.null(m))then return m from cache, else m is not cached yet, goto 2).
## 2) OPTIONAL: Use if implementing caching matrices by value, not by object. Before computing the
## inverse, search list keep to identify if another object has stored the same x and hence cached m.
## Search all elements/objects of keep w/ counter j, testing if:identical(keep[[j]]$get(),ob1$get()). 
## If TRUE then ob1 is substituted by object keep[[j]] which has cached m before, and m is returned.
## 3) Otherwise calculate m via build-in solve(), cache it first time, insert ob1 in keep as the "ith" 
## element. Global counter i increases globally via operator "<<-" right after to point to the next 
## empty space in keep. We get x by calling: data <- ob1$get(),compute m by: m <- solve(data, ...), 
## store/cache m in ob1: ob1$setInv(m). m will be used for any subsequent object mapped to x (my option).

cacheSolve <- function(x, ...) {
         ## Return a matrix that is the inverse of 'x'

          m <- x$getInv()
          if (!is.null(m)) {
                  message("getting cached data")
                  return(m)
          }

          if (i>1) {
                    stmt <- "FALSE"
                    for (j in 1:(i-1)) {
                             stmt <- identical(keep[[j]]$get(),x$get())
                             if (stmt) {
                                    x <- keep[[j]]
                                    m <- x$getInv()
                                    message("getting cached data")
                                    return(m)
                             } 
                    }
        }
               
        keep[[i]] <<- x 
        i <<- i+1
        data <- x$get()
        m <- solve(data, ...)
        x$setInv(m)
        message("getting non-cached data")
        m
}
